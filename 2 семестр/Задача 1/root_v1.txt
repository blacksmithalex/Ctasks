Для выбранного метода численного поиска корня:
1) Пишем функцию для численного поиска корня.
Аргументы функции:
а) концы отрезка или единственная стартовая точка (зависит от метода),
б) количество итераций
в) функция у которой ищется корень.
root(double a, double b, int N, double (*f)(double) )

2) Проводим исследование.
Для функций из списка:
а) линейная,
б) парабола,
в) sin
г) хитрая
исследуем поведение численного значения x_n корня функции f с изменением N.
Учитываем и разные стартовые положения отрезка/точки.
Замечу,
что для заданных функций мы должны знать истинный корень x_*.
Функция (её производная) задается на С/С++:
double f(double x)
{
    return x*x + 2*x -10;
}

Для некоторых функций уже при небольшом n численное вычисление корня x_N будет давать идеальный ответ.
Для других функций численный поиск корня x_n даст погрешность.
В последнем случае нужно понять:
а) как меняется ошибка с ростом n (на 1): x_n - x_*.
б) как меняется значение функции с ростом n (на 1): f(x_n). (Она же должна стремится к 0).
в) как меняется разница между численно посчитанными корнями с ростом n: x_n - x_{n-1}.
Для данных величин конечно записывается абсолютная величина.
И пишем форматом %e, т.е.
printf("%e", v);
где v величины из а, б и в выше.
