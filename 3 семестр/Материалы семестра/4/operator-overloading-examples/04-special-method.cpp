#include <iostream>

class Complex {
 private:
  double re;
  double im;
 public:

  Complex() :
    re(0),
    im(0)
  { }

  Complex(double re, double im) :
    re(re),
    im(im)
  { }

  double Re() const { return re; }
  double& Re() { return re; }
  double Im() const { return im; }
  double& Im() { return im; }

  /* Переопределяем операцию сложения. По смыслу операция должна возвращать новый
     объект. Операция бинарная, у неё есть два аргумента. Левым аргументом неявно
     является сам объект, у которого эта операция вызвана, а правый аргумент передаётся
     в круглых скобках. По смыслу операция не должна менять своих аргументов, поэтому
     метод константный, а аргумент передаётся по константной ссылке. */
  Complex operator+(const Complex& other) const {
    /* Вызываем конструктор и создаём новый объект. */
    return Complex(re + other.re, im + other.im);
  }

  /* Переопределяем операцию +=. Она также является бинарной, левым аргументом
     неявно является сам объект, у которого вызывается данный метод, правый аргумент
     передаётся в скобках. По смыслу операция может поменять левый аргумент,
     но не должна менять правый. Поэтому метод неконстантный, а правый аргумент
     передаётся по константной ссылке. По смыслу операция не создаёт новый объект,
     однако, обычно можно написать A = (B += C), поэтому операция возвращает ссылку
     на сам объект. */
  Complex& operator+=(const Complex& other) {
    re += other.re;
    im += other.im;

    /* Возвращаем текущий объект по ссылке. Специальная переменная this в классе
       содержит указатель на текущий объект, у которого в данный момент вызван метод.
       Пусть есть объект obj класса Cls, у него вызывается метод Method(). Если данный
       метод не является константным, то внутри него переменная this будет иметь
       тип Cls* и равняться &obj. Если данный метод является константным, то внутри
       него переменная this будет иметь тип const Cls* и равняться &obj. То есть
       значение зависит от того объекта, у которого метод вызывается. */
    return *this;      
  }

  /* Всё то же самое. */
  Complex operator-(const Complex& other) const {
    return Complex(re - other.re, im - other.im);
  }

  /* Операция - "минус" бывает не только бинарная, но и унарная. Такая операция
     принимает только один аргумент. В данном случае он уже неявно задан --- это
     сам объект, у которого метод вызван. По смыслу операция возвращает новый объект
     и не должна менять свой аргумент. */
  Complex operator-() const {
    return Complex(-re, -im);
  }

  /* Всё то же самое. */
  Complex& operator-=(const Complex& other) {
    re -= other.re;
    im -= other.im;

    return *this;
  }
};

int main() {
  Complex c1(1, 2);
  Complex c2(3, 4);
  Complex c3;

  // Здесь у объекта c1 будет вызван метод operator+() и в него передастся аргумент c2.
  c3 = c1 + c2;

  // Это эквивалентно следующей строчке:
  c3 = c1.operator+(c2);

  /* Пример использования операции +=. */
  c3 += c2;

  /* Пример использования унарного минуса. */
  c3 = -c2;

  std::cout << "(" << c3.Re() << ", " << c3.Im() << ")" << std::endl;
  return 0;
}

